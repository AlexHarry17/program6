diff --git a/src/Graph.java b/src/Graph.java
index dd57e6a..a566147 100644
--- a/src/Graph.java
+++ b/src/Graph.java
@@ -1,5 +1,4 @@
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Comparator;
 import java.util.PriorityQueue;
 
@@ -7,13 +6,13 @@ import java.util.PriorityQueue;
 Authors: Alex Harry, Cory Johns, Justin Keeling
 Date: April 2, 2018
 Overview: Graph stores a two-dimensional array representation of the graph in the input file and
-contains all the functions for running Prim’s, kruskal’s, and Floyd-Warshall's Algorithms as well as
+contains all the functions for running Prim’s, Kruuskal’s, and Floyd-Warshall's Algorithms as well as
 printing the graph.
 */
 public class Graph {
     private int graph_size = 0;
     private ArrayList<ArrayList<Integer>> graph = new ArrayList<ArrayList<Integer>>();
-    private ArrayList<Vertex> vertexes;
+    private ArrayList<String> vertexes;
 
     public Graph() {
 
@@ -39,10 +38,10 @@ public class Graph {
      */
     public void set_vertexes(String[] names) {
         // Initialize the name list
-        vertexes = new ArrayList<Vertex>();
+        vertexes = new ArrayList<String>();
         // append each name
         for (String name : names) {
-            vertexes.add(new Vertex(name));
+            vertexes.add(name);
         }
     }
 
@@ -69,118 +68,83 @@ public class Graph {
         }
     }
 
-    
     public void prim() {
-    	/* definitions : 
-    	 * - MST is a list of edges
-    	 * - Edge is a class containing the weight, vertex 1, vertex 2 for the edge, the print value is vertex1.name + vertex2.name
-    	 * - vertex is a class containing the vertex name, visited flag
-    	 * Need:
-    	 * - a list of all vertex objects (already implemented as the global vertexes field)
-    	 * - MST (empty at start)
-    	 * - a list of all edges in the graph but don’t include duplicates (QueueEdge.equals will work here)
-    	 * 	- start the list of edges with references to the list of vertexes (use QueueEdge it is already set up for the priority queue)
-    	 */
-    	// set up the list of edges without duplicates
-
-    	// pick a start vertex
-
-    	// set vertex as visited
-
-    	// while MST has less then the number of vertexes - 1 edges in it
-
-    		// for all vertexes in the MST (i.e. all vertexes with visited == true)
-    			
-    			// make the cut i.e.:
-    			// add all edges containing the visited vertexes in position 1 to a priority queue if visited is false for vertex 2
-
-    		// pick the best one
-
-    		// set vertex 2 as visited
-
-    		// add the corresponding edge to to the MST (i.e. vertex1 -> vertex2)
-    	
-    	
-    	
-    	/*
-        // copy graph for use here
-        ArrayList<ArrayList<Integer>> matrix_D = duplicate_matrix(graph);
-
         //starting vertex
         Vertex current = null;
-
         //used to randomly choose starting vertex
-        int random_start = (int) (Math.random() * graph_size);
+        int random_start = 0;//(int) (Math.random() * graph_size);
 
-        //add all vertices to an Arraylist
+        //add all vertices to an ArrayList
         ArrayList<Vertex> vertices = new ArrayList<>();
+        ArrayList<Vertex> mst = new ArrayList<>();
 
         for (int i = 0; i < graph_size; i++) {
-            //creates a new vertex with its 'edge' currently set to null and infinity, and the vertex's status is false.
-            Vertex vertex = new Vertex(new MST_LinkedList(null, Main.infinity), false, i);
 
-            //chooses 'start' equal to the'vertex' when 'i' = 'rand_start'
+            //creates a new vertex with its 'edge' being the edge connecting it to its predecessor(Parent).
+            //Vertex also contains 'visited' of whether or not it has been visited & its index in array list.
+            //Edge contains predecessor starting at null, and weight at infinity.
+            Vertex vertex = new Vertex(new Edge(Integer.MAX_VALUE, null), false, i);
+            //chooses 'start' equal to the'vertex' when 'i' = 'rand_start'.
             if (random_start == i) {
-                //set the 'start' vertex's status to true, and its length to 0: Requirements for start vertex
+                //set the 'current' vertex's visited to true, and its length to 0: Requirements for start vertex.
                 current = vertex;
-                current.status = true;
+                current.visited = true;
                 current.edge.weight = 0;
                 vertices.add(current);
+                // add the starting vertex, 'current' , to mst.
+                mst.add(current);
+                System.out.println("start Current Index = " + current.index + "\nrandstart = " + random_start);
             } else {
                 vertices.add(vertex);
             }
         }
-        // instance variable to put into a queue of edges
-        Vertex compare = null;
-        PriorityQueue<MST_LinkedList> edges = new PriorityQueue<MST_LinkedList>(graph_size, new MST_LL_Comparator());
-
-        int min = Main.infinity;
-
-        //checks the current vertexes edges from graph to put into queue
-        for (int v = 0; v < graph_size; v++) {
-            // vertex v from graph must not equal the current vertex, and must not be visited.
-            if (v != current.index && !vertices.get(v).status) {
-                // set 'compare' equal to the vertex object
-                compare = vertices.get(v);
-                //find the edge weight to put into queue
-                compare.edge.weight = matrix_D.get(current.index).get(v);
-                //assigns the predecessor as the current vertex
-                compare.edge.pd = current;
-                // add the edge to the queue
-                edges.add(compare.edge);
-                current = compare;
-            }
-            while (!edges.isEmpty()) {
-
+        PriorityQueue<Edge> edges = new PriorityQueue<Edge>(graph_size * graph_size, new Edge_Comparator());
+        // obtains all the possible edges and puts them into PriorityQueue.
+        edges = add_to_queue(vertices, current, edges);
+
+        while (!edges.isEmpty() || mst.size() < graph_size) {
+            // obtains the minimum edge.
+            Edge min_edge = edges.poll();
+            System.out.println("min_edge.weight = "+ min_edge.weight + "\nmin_edge.predecessor.index = " + min_edge.predecessor.index);
+            // obtains the new current vertex.
+            Vertex temp_vertex = vertices.get(min_edge.index);
+
+            if (!temp_vertex.visited) {
+                // adds the new current vertex to the tree.
+                current = temp_vertex;
+
+                mst.add(current);
+                current.visited = true;
+                System.out.println(vertices.get(current.index));
             }
+            edges = add_to_queue(vertices, current, edges);
         }
-        current.edge = edges.poll();*/
     }
 
-    public void kruskal() {
-
-        ArrayList<String> t = new ArrayList<String>(); //instantiates array t to return
-        ArrayList<ArrayList<Integer>> d = duplicate_matrix(graph);  // copy of graph
-        PriorityQueue<QueueEdge> q = new PriorityQueue<QueueEdge>();    //creates a priority queue for kruskal algo
+    private PriorityQueue<Edge> add_to_queue(ArrayList<Vertex> vertices, Vertex current, PriorityQueue<Edge> e) {
         for (int i = 0; i < graph_size; i++) {
-        	// loop though only the upper diagonal, by starting j at i
-            for (int j = i; j < graph_size; j++) {
-                if (!is_max_value(d.get(i).get(j))) { // checks if vertex is not infinity
-                    if (i != j) {   //checks that j != b, ex. A = A
-                        q.add(new QueueEdge(d.get(i).get(j), vertexes.get(i), vertexes.get(j))); // Adds to the queue
-                    }
-                }
+
+            //if the edge in the graph does not equal infinity from the current vertex to the i'th vertex, set i'th vertex edge-weight.
+            if (graph.get(current.index).get(i) != Integer.MAX_VALUE && !vertices.get(i).visited) {
+                vertices.get(i).edge.weight = graph.get(current.index).get(i);
+
+                //set the vertex's edge predecessor to the current node.
+                vertices.get(i).edge.predecessor = current;
+                vertices.get(i).edge.index = i;
+               ////// System.out.println(" add_to_queue if statement: edge.weight = " + vertices.get(i).edge.weight);
+                //add to queue
+                e.add(vertices.get(i).edge);
             }
         }
-        do {    //loops while q is not empty
-            QueueEdge temp = q.poll();  // temp variable that pulls from the queue
-            if (!temp.getVert1().equals(temp.getVert2())) {
-                t.add((temp.getVert1().name + temp.getVert2().name));    // adds to t array list
-            }
-        } while (!q.isEmpty());
-        System.out.println(t);  // prints array list
+        //returns the priority queue with new edges
+
+        return e;
     }
 
+    public void kruuskal() {
+        // copy graph for use here
+        ArrayList<ArrayList<Integer>> d = duplicate_matrix(graph);
+    }
 
     /**
      * Runs Floyd-Warshall's algorithm on the instance variable graph
@@ -189,11 +153,6 @@ public class Graph {
     public void floyd_warshall() {
         // copy graph for use here
         ArrayList<ArrayList<Integer>> d = duplicate_matrix(graph);
-        
-        // set diagonal to 0
-        for (int i=0; i < graph_size; i++) {
-        	d.get(i).set(i, 0);
-        }
 
         // find the shortest path
         for (int k = 0; k < graph_size; k++) {
@@ -262,7 +221,7 @@ public class Graph {
      * @param matrix
      * @param vertex_names
      */
-    public void print_graph(ArrayList<ArrayList<Integer>> matrix, ArrayList<Vertex> vertex_names) {
+    public void print_graph(ArrayList<ArrayList<Integer>> matrix, ArrayList<String> vertex_names) {
         // print a spacer
         System.out.print("  ");
         // print vertex names along the top of the matrix
@@ -305,45 +264,46 @@ public class Graph {
         }
     }
 
-//    public static class Vertex {
-//
-//        MST_LinkedList edge;
-//        boolean status;
-//        int index;
-//
-//        public Vertex(MST_LinkedList in_edge, boolean in_status, int in_index) {
-//            // variable to hold status if it has been visited or not
-//            status = in_status;
-//            // edge to get weight of a vertex.
-//            edge = in_edge;
-//            // index from array
-//            index = in_index;
-//        }
-//    }
-//
-//    public static class MST_LinkedList {
-//        //essentially parent
-//        Vertex pd;
-//
-//        int weight;
-//
-//        public MST_LinkedList(Vertex in_pd, int in_length) {
-//            pd = in_pd;
-//            weight = in_length;
-//        }
-//    }
-//
-//    public static class MST_LL_Comparator implements Comparator<MST_LinkedList> {
-//        // used to compare weights of edges.
-//        @Override
-//        public int compare(MST_LinkedList e1, MST_LinkedList e2) {
-//            if (e1.weight < e2.weight) {
-//                return 1;
-//            } else if (e1.weight > e2.weight) {
-//                return -1;
-//            }
-//            return 0;
-//        }
-//    }
+    public static class Vertex {
+        // the edge that connects this vertex to its predecessor.
+        Edge edge;
+        // variable to hold visited if it has been visited or not
+        boolean visited;
+        // index from array
+        int index;
+
+        public Vertex(Edge in_connecting_to_this_vertex, boolean in_status, int in_index) {
+            visited = in_status;
+            edge = in_connecting_to_this_vertex;
+            index = in_index;
+        }
+    }
+
+    public static class Edge {
+        // weight of edge
+        int weight;
+        // The parent,essentially, : The vertex in which the edge comes from,
+        // the edge's vertex is the vertex the edge connects to
+        Vertex predecessor;
+        int index;
+
+        public Edge(int in_weight, Vertex in_pd) {
+            weight = in_weight;
+            predecessor = in_pd; // may not need.
+        }
+    }
+
+    public class Edge_Comparator implements Comparator<Edge> {
+        // used to compare weights of edges.
+        @Override
+        public int compare(Edge e1, Edge e2) {
+            if (e1.weight < e2.weight) {
+                return -1;
+            } else if (e1.weight > e2.weight) {
+                return 1;
+            }
+            return 0;
+        }
+    }
 }
 
diff --git a/src/InputGenerator.java b/src/InputGenerator.java
index f6bb5ae..61fcab1 100644
--- a/src/InputGenerator.java
+++ b/src/InputGenerator.java
@@ -11,9 +11,8 @@ import java.util.Random;
 Authors: Alex Harry, Cory Johns, Justin Keeling
 Date: April 4, 2018
 Overview: Program generates a specified number of matrixes of random size and contents 
-and can generate symmetric, non-symmetric, and connected matrixes. Outputs results to the console and ./input/input.csv.
-Graphs may not be connected if from symmetric or non-symmetric.
-connected matrixes are also symmetric
+and can generate symmetric, non-symmetric, and non-cyclic matrixes. Outputs results to the console and ./input/input.csv.
+Graphs may not be connected
 */
 public class InputGenerator {
 	// string to represent infinity
@@ -49,7 +48,7 @@ public class InputGenerator {
 			// repeat a select number of times
 			for (int i=0; i<pairs; i++) {
 				// randomly pick a type of matrix
-				int random_selector = 3;//random.nextInt(100) % 3;
+				int random_selector = random.nextInt(100) % 3;
 				if (random_selector == 0) {
 					matrix = non_symmetric(matrix, random);
 				}
@@ -57,7 +56,7 @@ public class InputGenerator {
 					matrix = symmetric(matrix, random);
 				}
 				else {
-					matrix = connected(matrix, random);
+					matrix = non_cyclic(matrix, random);
 				}
 				
 				// print matrix to both outputs
@@ -129,34 +128,36 @@ public class InputGenerator {
 	}
 	
 	/**
-	 * Makes a connected matrix by making a symmetric matrix and then making sure there are no vertexes with 
-	 * no edges
+	 * Makes a noncyclic matrix by only adding edges to higher/lower vertexes but never both
 	 * @param matrix
 	 * @param random
 	 * @return the initialized matrix
 	 */
-	private static String[][] connected(String[][] matrix, Random random){
-		// symmetric matrixes are naturally connected if all vertexes have at least one connection
-		String[][] base = symmetric(matrix, random);
+	private static String[][] non_cyclic(String[][] matrix, Random random){
+		// pick a random side of the diagonal, random_side will be ether a 0 or a 1
+		int random_side = random.nextInt(100) % 2;
 		
-		// check for unconnected vertexes
-		for (int i=0; i<base.length; i++) {
-			boolean goodrow = false;
-			for (int j=0; j<base[i].length; j++) {
-				if (!base[i][j].equals(INF)) {
-					goodrow = true;
-					break;
+		// initialize array
+		for (int i=0; i<matrix.length; i++) {
+			for (int j=0; j<matrix[i].length; j++) {
+				// guarantee noncyclic by not including values for one side of the diagonal
+				// if random_side is a 0 the upper side will be picked
+				if ((i - j)*(1 - 2*random_side) < 0) {
+					// randomly assign either an int or INF to the current location
+					if ((random.nextInt((max_size - min_size) + 1) + min_size) % 3 == 0) {
+						matrix[i][j] = "" + random.nextInt(max + 1);
+					}
+					else {
+						matrix[i][j] = "" + INF;
+					}
 				}
-			}
-			if (!goodrow) {
-				// select a random location
-				int tmp = random.nextInt(base[i].length);
-				// give a random edge weight and ensure symmetry
-				base[i][tmp] = "" + random.nextInt(max + 1);
-				base[tmp][i] = base[i][tmp];
+				else {
+					matrix[i][j] = "" + INF;
+				}
+				
 			}
 		}
-		return base;
+		return matrix;
 	}
 	
 	/**
diff --git a/src/Main.java b/src/Main.java
index 6a4c5d6..fbffbf3 100644
--- a/src/Main.java
+++ b/src/Main.java
@@ -11,7 +11,7 @@ Overview: Program reads in the graph containing the adjacency matrix from the in
 and repeats the following until there are no more graphs remaining in the input:
 	- prints the graph
 	- runs Prim’s Algorithm and prints the edges in the minimum spanning tree
-	- runs kruskal’s Algorithm and prints the edges in the minimum spanning tree
+	- runs Kruuskal’s Algorithm and prints the edges in the minimum spanning tree
 	- runs Floyd-Warshall's Algorithm and prints every step in finding all the shortest paths
 */
 public class Main {
@@ -66,11 +66,11 @@ public class Main {
                     	
                     	// run the Prim’s algorithm part
                     	System.out.println("Started Prim’s Algorithm...");
-                    	//graph.prim();
+                    	graph.prim();
                     	
-                    	// run the kruskal’s algorithm part
-                    	System.out.println("Started Kruskal’s Algorithm...");
-                    	graph.kruskal();
+                    	// run the Kruuskal’s algorithm part
+                    	System.out.println("Started Kruuskal’s Algorithm...");
+                    	graph.kruuskal();
                     	
                     	// run the Floyd-Warshall's algorithm part
                     	System.out.println("Started Floyd-Warshall's Algorithm...");
